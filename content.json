{"meta":{"title":"Jerry's Blog","subtitle":null,"description":"ops.linux","author":"Jerry","url":"https://zhusas.github.io"},"pages":[{"title":"about","date":"2018-06-01T08:02:08.000Z","updated":"2018-06-01T08:02:08.468Z","comments":true,"path":"about/index.html","permalink":"https://zhusas.github.io/about/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-06-01T08:01:47.000Z","updated":"2018-06-01T08:01:47.929Z","comments":true,"path":"tags/index.html","permalink":"https://zhusas.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Linux的基础知识","slug":"Linux的基础知识","date":"2018-08-02T06:22:00.000Z","updated":"2018-08-02T06:26:20.442Z","comments":true,"path":"2018/08/02/Linux的基础知识/","link":"","permalink":"https://zhusas.github.io/2018/08/02/Linux的基础知识/","excerpt":"一、计算机的组成及其功能硬件冯·洛伊曼体系 控制器(Control)：是整个计算机的中枢神经，其功能是对程序规定的控制信息进行解释，根据其要求进行控制，调度程序、数据、地址，协调计算机各部分工作及内存与外设的访问等。 运算器(Datapath)：运算器的功能是对数据进行各种算术运算和逻辑运算，即对数据进行加工处理。 存储器(Memory)：存储器的功能是存储程序、数据和各种信号、命令等信息，并在需要时提供这些信息。 输入(Input system)：输入设备是计算机的重要组成部分，输入设备与输出设备合称为外部设备，简称外设，输入设备的作用是将程序、原始数据、文字、字符、控制命令或现场采集的数据等信息输入到计算机。常见的输入设备有键盘、鼠标器、光电输入机、磁带机、磁盘机、光盘机等。 输出(Output system)：输出设备与输入设备同样是计算机的重要组成部分，它把外算机的中间结果或最后结果、机内的各种数据符号及文字或各种控制信号等信息输出出来。微机常用的输出设备有显示终端CRT、打印机、激光印字机、绘图仪及磁带、光盘机等。","text":"一、计算机的组成及其功能硬件冯·洛伊曼体系 控制器(Control)：是整个计算机的中枢神经，其功能是对程序规定的控制信息进行解释，根据其要求进行控制，调度程序、数据、地址，协调计算机各部分工作及内存与外设的访问等。 运算器(Datapath)：运算器的功能是对数据进行各种算术运算和逻辑运算，即对数据进行加工处理。 存储器(Memory)：存储器的功能是存储程序、数据和各种信号、命令等信息，并在需要时提供这些信息。 输入(Input system)：输入设备是计算机的重要组成部分，输入设备与输出设备合称为外部设备，简称外设，输入设备的作用是将程序、原始数据、文字、字符、控制命令或现场采集的数据等信息输入到计算机。常见的输入设备有键盘、鼠标器、光电输入机、磁带机、磁盘机、光盘机等。 输出(Output system)：输出设备与输入设备同样是计算机的重要组成部分，它把外算机的中间结果或最后结果、机内的各种数据符号及文字或各种控制信号等信息输出出来。微机常用的输出设备有显示终端CRT、打印机、激光印字机、绘图仪及磁带、光盘机等。 软件低级语言：汇编语言，汇编器；写驱动 高级语言：系统级：C，C++，对性能要求较高的服务类程序应用级：Java,Python,Ruby 二、Linux 发行版有数百种之多，主要分三个主流分支RedHat Enterprise LinuxRedhat系列，包括RHEL(Redhat Enterprise Linux，也就是所谓的Redhat Advance Server，收费版本)、Fedora Core(由原来的Redhat桌面版本发展而来，免费版本)、CentOS(RHEL的社区 克隆版本，免费)。Redhat是在国内使用人群最多的Linux版本，甚至有人将Redhat等同于Linux。所以这个版本的特点就是使用人群数量大，资料非常多，言下之意就是如果你有什么不明白的地方，很容易找到人来问，而且网上的一般Linux教程都是以Redhat为例来讲解的。Redhat系列的包管理方式采用的是基于RPM包的YUM包管理方式，包分发方式是编译好的二进制文件。稳定性方面RHEL和CentOS的稳定性非常好，适合于服务器使用，但是Fedora Core的稳定性较差，最好只用于桌面应用。 CentOS 是一个基于Red Hat Linux 提供的可自由使用源代码的企业级Linux发行版本。每个版本的 CentOS都会获得十年的支持（通过安全更新方式）。新版本的 CentOS 大约每两年发行一次，而每个版本的 CentOS 会定期（大概每六个月）更新一次，以便支持新的硬件。这样，建立一个安全、低维护、稳定、高预测性、高重复性的 Linux 环境。CentOS是Community Enterprise Operating System的缩写。CentOS 是RHEL（Red Hat Enterprise Linux）源代码再编译的产物，而且在RHEL的基础上修正了不少已知的 Bug ，相对于其他 Linux 发行版，其稳定性值得信赖。 Debian：只有社区的发行版Debian系列，包括Debian和Ubuntu等。Debian是社区类Linux的典范，是迄今为止最遵循GNU规范的Linux系统。Debian最早由Ian Murdock于1993年创建，分为三个版本分支（branch）： stable, testing 和unstable。其中，unstable为最新的测试版本，其中包括最新的软件包，但是也有相对较多的bug，适合桌面用户。testing的版本都经过unstable中的测试，相对较为稳定，也支持了不少新技术（比如SMP等）。而stable一般只用于服务器，上面的软件包大部分都比较过时，但是稳定和安全性都非常的高。Debian最具特色的是apt-get / dpkg包管理方式，其实Redhat的YUM也是在模仿Debian的APT方式，但在二进制文件发行方式中，APT应该是最好的了。Debian的资料也很丰富，有很多支持的社区，有问题求教也有地方可去。Debian是包括Ubuntu在内许多发行版的上游，而Ubuntu又是Linux Mint及其他发行版的上游。Debian在服务器和桌面电脑领域都有着广泛的应用。Debian是一个纯开源计划并着重在一个关键点上，稳定性。它同时也提供了最大的和完整的软件仓库给用户。 Ubuntu是基于Debian的unstable版本加强而来，可以这么说，Ubuntu就是一个拥有Debian所有的优点，以及自己所加强的优点的近乎完美的 Linux桌面系统。根据选择的桌面系统不同，有三个版本可供选择，基于Gnome的Ubuntu，基于KDE的Kubuntu以及基于Xfc的Xubuntu。特点是界面非常友好，容易上手，对硬件的支持非常全面，是最适合做桌面系统的Linux发行版本。 Slackware LinuxSlackware Linux是由Patrick Volkerding开发的GNU/Linux发行版。与很多其他的发行版不同，它坚持KISS(Keep It Simple Stupid)的原则。一开始，配置系统会有一些困难，但是更有经验的用户会喜欢这种方式的透明性和灵活性。 Slackware 很多特性体现出了KISS原则，最为有名的一些例子就是不依赖图形界面的文本化系统配置、传统的服务管理方式和不解决依赖的包管理方式。它的最大特点就是安装灵活，目录结构严谨，版本力求稳定而非追新。Slackware的软件包都是通常的tgz(tar/gzip) 或者txz(xz) 格式文件再加上安装脚本。Tgz/Txz 对于有经验的用户来说，比RPM更为灵活，并避免了APT 之类管理器可能带来的的依赖地狱。 作为开源软件，Slackware与商业版本的关系并不大，但与几家提供付费支持的厂商一直保持的合作关系。作为最早的可用版本之一，Slackware Linux是由Patrick Volkerding开发的GNU/Linux发行版。与很多其他的发行版不同，它坚持KISS(Keep It Simple Stupid)的原则，就是说尽量不依赖配置系统的图形界面工具。其安装程序也是一些Dialog界面的shell脚本写成，你可以在安装的任何时候跳到任何安装步骤，而且这些脚本在安装之后也可以很方便的使用 Slackware与其他的发行版本（Red Hat、Debian、Gentoo、SuSE、 Mandriva、Ubuntu等）不同的道路，它力图成为“UNIX风格”的Linux发行版本。只吸收稳定版本的应用程序，并且缺少其他linux版本中那些为发行版本定制的配置工具。在当今systemd大势所趋的情况下，Slackware仍然坚持BSD启动风格。 Slackware主要为x86 PC开发，从2005年起开始出现针对System/390架构的官方移植。同时ARM、DEC Alpha、SPARC和PowerPC也存在一些非官方的移植。Slackware官方维护着一个开发版本（Slackware Current），不断有新的软件被加入到这个源，用户可以实现类似Archlinux的滚动升级，等到一个开发版本足够稳定，便会发布一个稳定版。Slackware是支持x86、amd64（即x86_64）、ARM、Alpha、SPARC、PowerPC的一套GNU/Linux操作系统，其正式发布由PatrickVolkerding 负责。 Linux发行版汇总 Linux各发行版的联系与区别：联系： 各发行版本均采用Linux的内核（kernel）； 各发行版本均遵守GPL版权协定； 各发行版本均遵循 Linux Standard Base (LSB)等标准来开发； 各发行版本均遵循FHS（File system Hierarchy Standard）标准规范； 区别： 不同的发行版采用的软件包管理方式不同；最有名的是 debain 的 deb 包，redhat 的 rpm 包，slackware 等的 tgz 包。 发行初衷不同，导致特点也不同，见下图： 三、Linux的哲学思想 一切皆文件 由众多的单一的程序完成一件比较复杂的工作，一个程序只做一件事，并且做好他。 尽量避免与用户交互 使用文本文件保存配置信息 提供机制（可选的策略、是一种框架），而非策略，提供做大的灵活性。 四、Linux系统上常用命令的使用格式命令的语法通用格式：COMMAND OPTIONS ARGUMENTS COMMAND说明发起命令时将请求内核将某个二进制程序运行为一个进程，命令本身是一个可执行的程序文件，二进制格式的文件有可能会调用共享库文件。[遵循ELF格式规范] 多数系统命令程序文件都存放在：/bin,/sbin,/usr/bin,/usr/sbin,/usr/local/bin,/usr/local/sbin，它们又分为普通命令和管理命令。 普通命令：存放在/bin,/usr/bin,/usr/local/bin 管理命令：存放在/sbin,/usr/sbin,/usr/local/sbin 用到的库文件都存放在：/lib,/lib64,/usr/lib,/usr/lib64,/usr/local/lib,/usr/local/lib64，它们分为32位和64位的库文件，32位使用于32位的操作系统，64位使用于64位的操作系统，64位兼容32位，而32不兼容64 32位库：存放在/lib,/usr/lib,/usr/local/lib 64位库：存放在/lib64,/usr/lib64,/usr/local/lib64 命令分为两类：​由shell自带的命令，叫作内嵌命令(builtin) 独立的可执行程序文件，文件名即命令名，叫作外部命令 查看命令的内容的类型： file命令： 例：~]# file /bin/ls 查看命令的类型： type命令： 例：~]# type COMMAND 注意：并非所有的命令都有一个在某目录与之对应的可执行程序文件 OPTIONS说明：指定命令的运行特性，有两种表现形式： 短选项：-C，例如 ls -l ,-d 注：有的命令选项没有 – ，同一命令同时使用多个短选项可合并：ls -ld 长选项：–word，例如 ls –help，有时候选项也带参数，例：du -h –max-depth=1 注：长选项不能合并 ARGUMENTS说明：参数：命令的作用对象，命令对什么生效，例：ls /etc ,作用在/etc 。注：有些命令可以可同时带多个参数，以空白分隔 常用命令示例：ifconfig作用：显示和配置网络信息 语法：ifconfig [网络设备][参数] 示例：ifconfig -a echo作用：显示文本 语法：echo [-ne][字符串]或 echo [–help][–version] 示例：echo ‘Hello World’ tty作用：显示终端机连接标准输入设备的文件名称 语法：tty [-s][–help][–version] 示例：tty startx作用：进入图形操作界面 示例：startx &amp; export作用：设置或显示环境变量 语法：export [-fnp][变量名称]=[变量设置值] 示例： 123export JAVA_HOME = /home/myuser/jdk1.7.0_03export PATH = $JAVA_HOME/bin:$PATHexport CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar pwd作用：显示当前工作目录 语法：pwd[–help][–version] 示例：pwd history作用：列出bash保存的所有历史命令 语法：history [选项] 示例1：history 示例2:使用HISTTIMEFORMAT环境变量在历史中显示TIMESTAMP 123456789101112131415命令：export HISTTIMEFORMAT='%F %T '$history输出如下：642 2016-10-25 17:05:46 ll643 2016-10-25 17:05:46 rm 333 644 2016-10-25 17:05:46 ll /etc/fstab 645 2016-10-25 17:05:51 history --help646 2016-10-25 17:05:59 history -h647 2016-10-25 17:06:14 man history648 2016-10-25 17:07:53 history 649 2016-10-25 17:07:57 export HISTTIMEFORMAT='%F %T '650 2016-10-25 17:07:59 history shutdown作用：系统关机命令 语法：shutdown [-cfFhknr][-t 秒数][时间][警告信息] 示例：shuntdown -r +5 poweroff作用：关机 语法：这个命令还说啥语法啊，生产环境上不要随便执行这个命令，否则会被捆绑、滴蜡、爆菊啊~ 示例：poweroff reboot作用：重启 语法：运维常用作死命令之一，最好在头脑清醒的前提下执行。 示例：reboot hwclock作用：用来查询和设置硬件时钟 语法： 123-r, --show 读取并打印硬件时钟（read hardware clock and print result ）-s, --hctosys 将硬件时钟同步到系统时钟（set the system time from the hardware clock ）-w, --systohc 将系统时钟同步到硬件时钟（set the hardware clock to the current system time ） 示例： 12[root@centos ~]# hwclock -r2016年10月25日 星期二 17时32分28秒 -0.671802 seconds date作用：取一个特定时间的linux时间戳 语法：date [参数]… [+格式] 示例： 12[root@centos ~]# date2016年 10月 25日 星期二 17:33:17 CST 五、如何在Linux系统上获取命令的帮助信息，请详细列出，并描述man文档的章节时如何划分的获取命令的使用帮助：12345678内部命令： help COMMAND外部命令： (1) 命令自带简要格式的使用帮助 # COMMAND –help (2) 使用手册：manual 位置：/usr/share/man # man COMMAND 先执行type COMMNAD 识别是内部命令还是外部命令 12345678910111213141516171819(3) info COMMAND 获取命令的在线文档；(4) 很多应用程序会自带帮助文档：/usr/share/doc/APP-VERSION README：程序的相关的信息； INSTALL: 安装帮助； CHANGES：版本迭代时的改动信息；(5) 主流发行版官方文档 http://www.redhat.com/doc(6) 程序官方的文档： 官方站点上的“Document”(7) 搜索引擎 google、baidu keyword filetype:pdf （输入文章类型更有针对性） keyword site:domain.tld man 文档章节如何划分使用手册：压缩格式的文件，有章节之分； /usr/share/man man1, man2, … 123456781：用户命令； （普通用户和管理员）2：系统调用；3：C库调用；4：设备文件及特殊文件；5：文件格式；（配置文件格式）6：游戏使用帮助；7：杂项；8：管理工具及守护进行； 请罗列Linux发行版的基础目录名称命名法则及其功用规定FHS：1FHS：全称Filesystem Hierarchy Standard，其定义了两层规范， /下面的各个目录应该要放什么数据：12345678910111213141516171819202122232425262728293031/bin：所有用户可用的基本命令程序文件；/sbin：供系统管理使用的工具程序；/boot：引导加载器必须用到的各静态文件：kernel，initramfs（initrd），grub等；/dev：存储特殊文件或设备文件；设备有两种类型：字符设备（线性设备）例如：键盘、显示器；块设备（随机设备）例如：硬盘、内存；/etc：系统程序的配置文件，只能为静态/home：普通用户的家目录的集中位置；一般每个普通用户的家目录默认为此目录下与用户名同名的子目录，/home/USERNAME；/root：管理员的家目录；可选/lib：为系统启动或根文件系统上的应用程序（/bin，/sbin等）提供共享库，以及为内核提供的内核参数模块； libc.so.：动态链接的C库； ld：运行时链接器/加载器； modules：用于存储内核模块的目录；/lib64：64位系统特有的存放64位共享库的路径；/media：便携式设备挂载点，cdrom，floppy等；/mnt：其它文件系统的临时挂载点；/opt：附加应用程序的安装位置；可选路径；/srv：当前主机为服务提供的数据；/tmp：为那些会产生临时文件的程序提供的用于存储临时文件的目录；可供所有用户执行写入操作；有特殊权限；/usr：usr Hierarchy，全局共享的只读数据路径；/var：/var Hierarchy，存储经常发生变化的数据的目录；","categories":[],"tags":[{"name":"linux","slug":"linux","permalink":"https://zhusas.github.io/tags/linux/"}]},{"title":"MySQL启用的SSL连接的思考与实践","slug":"mysql-ssl","date":"2018-08-01T10:21:00.000Z","updated":"2018-08-02T02:36:02.010Z","comments":true,"path":"2018/08/01/mysql-ssl/","link":"","permalink":"https://zhusas.github.io/2018/08/01/mysql-ssl/","excerpt":"MySQL启用的SSL连接的思考与实践 由于工作上的业务发展和等保三级合规的要求，需要考虑为MySQL启用SSL连接，那么今天就来说说这个怎么玩。其实一个月前已经在实现了用docker跑MySQL SSL了，只不过后到今天才有时间静下心来总结一下。 有必要使用为MySQL启用SSL吗？先来了解一下SSL吧： SSL（Secure Socket Layer：安全套接字层）利用数据加密、身份验证和消息完整性验证机制，为基于TCP等可靠连接的应用层协议提供安全性保证。","text":"MySQL启用的SSL连接的思考与实践 由于工作上的业务发展和等保三级合规的要求，需要考虑为MySQL启用SSL连接，那么今天就来说说这个怎么玩。其实一个月前已经在实现了用docker跑MySQL SSL了，只不过后到今天才有时间静下心来总结一下。 有必要使用为MySQL启用SSL吗？先来了解一下SSL吧： SSL（Secure Socket Layer：安全套接字层）利用数据加密、身份验证和消息完整性验证机制，为基于TCP等可靠连接的应用层协议提供安全性保证。 SSL协议提供的功能主要有： ​ 1、 数据传输的机密性：利用对称密钥算法对传输的数据进行加密。 2.、身份验证机制：基于证书利用数字签名方法对服务器和客户端进行身份验证，其中客户端的身份验证是可选的。 3、 消息完整性验证：消息传输过程中使用MAC算法来检验消息的完整性。 如果用户的传输不是通过SSL的方式，那么其在网络中数据都是以明文进行传输的，而这给别有用心的人带来了可乘之机。所以，现在很多大型网站都开启了SSL功能。同样地，在我们数据库方面，如果客户端连接服务器获取数据不是使用SSL连接，那么在传输过程中，数据就有可能被窃取。 所以，我认为启用SSL是一个不错的选择。 那么SSL如何工作在MySQL中的这里分两说，因为工作中我涉及到MySQL5.6和MySQL 5.7两个版本，它们在SSL连接的实现上也有少许区别。 MySQL5.6的SSL MySQL 5.6中的SSL文档非常详细，它解释了SSL的工作原理。但首先让我们说清楚一点：MySQL支持使用TLS（传输层安全性）协议在客户端和服务器之间建立安全（加密）连接。 TLS有时被称为SSL（安全套接字层），但MySQL实际上并不使用SSL协议进行安全连接，因为它提供弱加密。 因此，当我们有人说MySQL正在使用SSL时，它实际上意味着它正在使用TLS。您可以使用以下命令检查您使用的协议： 123456show status like &apos;Ssl_version&apos;;+---------------+---------+| Variable_name | Value |+---------------+---------+| Ssl_version | TLSv1.2 |+---------------+---------+ TLS使用加密算法来确保可以信任通过公共网络接收的数据。它具有检测数据更改，丢失或重放的机制。 TLS还包含使用X509标准提供身份验证的算法。 X509可以识别互联网上的某个人。在基本术语中，应该有一些称为“证书颁发机构”（或CA）的实体，它将电子证书分配给需要它们的任何人。证书依赖于具有两个加密密钥（公钥和密钥）的非对称加密算法。证书所有者可以将证书提供给另一方作为身份证明。证书由其所有者的公钥组成。使用该公钥加密的任何数据只能使用由证书所有者持有的相应密钥解密。 MySQL5.6只支持TLSv1，MySQL5.7则支持TLSv1, TLSv1.1, and TLSv1.2 。 MySQL支持使用TLS协议的加密连接： 使用OpenSSL 1.0.1或更高版本编译时，MySQL支持TLSv1，TLSv1.1和TLSv1.2协议。 当使用捆绑版本的yaSSL进行编译时，MySQL支持TLSv1和TLSv1.1协议。 使用SSL配置服务器时，客户端必须具有客户端证书。获得后，它可以使用SSL连接到服务器。MySQL5.6的客户端必须指定密钥和证书。否则，我们无法使用SSL连接到服务器。 如下： my.cnf配置文件如下： 1234567891011121314151617[mysqld]skip-host-cacheskip-name-resolvepid-file = /var/run/mysqld/mysqld.pidsocket = /var/run/mysqld/mysqld.sockdatadir = /var/lib/mysql#log-error = /var/log/mysql/error.log# Disabling symbolic-links is recommended to prevent assorted security riskssymbolic-links=0ssl-ca=/etc/mysql/certs/ca.pemssl-cert=/etc/mysql/certs/MySQL1-cert.pemssl-key=/etc/mysql/certs/MySQL1-key.pem[client]ssl-ca=/etc/mysql/certs/ca.pemssl-cert=/etc/mysql/certs/MySQL-client-cert.pemssl-key=/etc/mysql/certs/MySQL-client-key.pem 客户端连接： 1mysql --ssl-ca=/etc/mysql/certs/ca.pem --ssl-cert=/etc/mysql/certs/MySQL-client-cert.pem --ssl-key=/etc/mysql/certs/MySQL-client-key.pem MySQL5.7的SSL 默认情况下，如果服务器支持加密连接，MySQL程序将尝试使用加密进行连接，如果无法建立加密连接，则会回退到未加密的连接。有关影响加密连接使用的选项的信息 。MySQL基于每个连接执行加密，并且对给定用户使用加密可以是可选的或强制的。可以根据各个应用程序的要求选择加密或未加密的连接。在CREATE USER的时候，有SSL相关的参数可以选择，这个创建用户参数取决于其用户连接时，是否必须使用密钥文件连接MySQL。 这些在官方文档里面都有说明，可以去详细了解下。这里就不铺开了。 MySQL 5.7中的加密连接支持进行了一些改进。以下时间表总结了这些变化： 5.7.3：在客户端，明确的–ssl选项不再是建议性的，而是规定性的。如果服务器支持加密连接，则客户端程序可以通过仅指定–ssl选项来要求加密连接。 （以前，客户端必须指定–ssl-ca选项，或者所有三个–ssl-ca， –ssl-key和–ssl-cert选项。）连接尝试失败如果无法建立加密连接。客户端的其他–ssl-xxx选项在没有–ssl的情况下是建议性的：客户端尝试使用加密进行连接，但如果无法建立加密连接，则会回退到未加密的连接。 5.7.5：默认情况下启用服务器端–ssl选项值。 对于使用OpenSSL编译的服务器，auto_generate_certs和sha256_password_auto_generate_rsa_keys系统变量可用于在启动时启用SSL / RSA证书和密钥文件的自动生成和自动发现。对于证书和密钥自动发现，如果启用了–ssl并且未给出其他–ssl-xxx选项以明确配置加密连接，则服务器会在启动时尝试自动启用对加密连接的支持，如果它发现必需的证书和密钥文件在数据目录中。 5.7.6：mysql_ssl_rsa_setup实用程序可用于手动生成SSL / RSA证书和密钥文件。启动时自动发现SSL / RSA文件将扩展为适用于所有服务器，无论是使用OpenSSL还是使用yaSSL编译。 （这意味着无需启用auto_generate_certs即可进行自动发现。） 如果服务器在启动时发现CA证书是自签名的，则会向错误日志写入警告。 （如果服务器自动创建证书，则证书是自签名的，或者使用mysql_ssl_rsa_setup手动创建证书。） 5.7.7：如果服务器支持加密连接，则C客户端库会默认尝试建立加密连接。这会影响客户程序，如下所示： 如果没有–ssl选项，客户端将尝试使用加密进行连接，如果无法建立加密连接，则会回退到未加密的连接。 显式–ssl选项或同义词（–ssl = 1， - enable-ssl）的存在是规定性的：客户端需要加密连接，如果无法建立，则会失败。 使用–ssl = 0选项或同义词（–skip-ssl， - disable-ssl），客户端使用未加密的连接.此更改还会影响基于C客户端库的MySQL连接器的后续版本：Connector / C，Connector / C ++和Connector / ODBC。 5.7.8：require_secure_transport系统变量可用于控制与服务器的客户端连接是否必须使用某种形式的安全传输。 5.7.10：TLS协议支持从TLSv1扩展到TLSv1.1和TLSv1.2。服务器端的tls_version系统变量和客户端的–tls-version选项可以选择支持级别。 5.7.11：MySQL客户端程序支持–ssl-mode选项，使您可以指定与服务器的连接的安全状态。 –ssl-mode选项包括客户端–ssl和–ssl-verify-server-cert选项的功能。因此，不推荐使用–ssl和–ssl-verify-server-cert，MySQL 8.0中已经删除它们。 好，上边说了这么多，各位都看明白了吗？不明白也没关系，我下面用docker来演示 坑点：我用许多客户端应用程序对它进行了测试，无论是MySQL5.6或5.7，MySQL客户端连接服务端时必须指定客户端密钥。没有密钥，无法连接到服务器。某些较旧的应用程序可能不支持此功能。 所以啊，官档说的也不一定全对。 实践这里以MySQL5.6为例 1、建立目录 1234# mkdir -pv mysql_ssl_&#123;data,config,cert&#125;mkdir: created directory 'mysql_ssl_data'mkdir: created directory 'mysql_ssl_config'mkdir: created directory 'mysql_ssl_cert' 准备好数据、证书、配置等文件 2、启动容器 1docker run --name mysql5.6_ssl_test -v /data/mysql_ssl_data/:/var/lib/mysql -v /data/mysql_ssl_config/my.cnf:/etc/my.cnf -v /data/mysql_ssl_cert/:/etc/mysql/certs -p 3306:3306 mysql:5.6.40 3、因为MySQL5.6默认用户是不开启SSL认证的，需要进行如下操作： 12345#修改已存在用户 GRANT USAGE ON *.* TO `user`@`%` REQUIRE X509;#新建必须使用SSL用户grant all privileges on *.* to 'user'@'%' identified by '111111' with grant option;GRANT USAGE ON *.* TO `user`@`%` REQUIRE X509; 对于具有REQUIRE X509的帐户，客户端必须指定要连接的–ssl-key和–ssl-cert选项。 （建议但不要求也指定–ssl-ca，以便验证服务器提供的公共证书。）对于ISSUER和SUBJECT也是如此，因为这些REQUIRE选项意味着X509的要求。 好，现在无论是用图形化工具还是使用命令行客户端，都必须指定客户端的证书及密钥文件，加上账户密码，才能连接登录MySQL了。 参考资料： https://www.cnblogs.com/mysql-dba/p/7061300.html https://dev.mysql.com/doc/refman/5.7/en/encrypted-connection-protocols-ciphers.html https://dev.mysql.com/doc/refman/5.6/en/encrypted-connection-protocols-ciphers.html https://dev.mysql.com/doc/refman/5.6/en/encrypted-connections.html https://dev.mysql.com/doc/refman/5.7/en/encrypted-connections.html ​","categories":[],"tags":[{"name":"SSL,MySQL","slug":"SSL-MySQL","permalink":"https://zhusas.github.io/tags/SSL-MySQL/"}]},{"title":"MongoDB备份数据引擎升级","slug":"mongodb","date":"2018-07-09T05:38:00.000Z","updated":"2018-07-31T06:42:32.431Z","comments":true,"path":"2018/07/09/mongodb/","link":"","permalink":"https://zhusas.github.io/2018/07/09/mongodb/","excerpt":"MongoDB备份数据引擎升级准备工作 确认已经安装需要运行的MongoDB版本 确保有足够的空间进行数据导出导入 您必须使用MongoDB版本3.0或更高版本才能使用WireldTiger存储引擎。 如果使用较早的MongoDB版本，则必须在继续更改存储引擎之前升级MongoDB版本。本文使用的是MongoDB 3.6 本文使用docker来操作，请自行安装好docker环境。","text":"MongoDB备份数据引擎升级准备工作 确认已经安装需要运行的MongoDB版本 确保有足够的空间进行数据导出导入 您必须使用MongoDB版本3.0或更高版本才能使用WireldTiger存储引擎。 如果使用较早的MongoDB版本，则必须在继续更改存储引擎之前升级MongoDB版本。本文使用的是MongoDB 3.6 本文使用docker来操作，请自行安装好docker环境。 直接在裸机安装MongoDB 3.6进行操作亦可。 这里演示从MongoDB 2.6备份出来的数据还原到MongoDB 3.6 并以WireldTiger引擎启动运行 步骤 1、启动你要运行的MongoDB版本，本文用的是3.6 ，Docker运行，配置文件写明要以wiredTiger 启动。 1docker run -d --name $CONTAINER_NAME -v $DATA_PATH:/data/db -v $OLD_DATA_PATH:/data2 -v /$CONFIG_PATH/mongod.conf:/etc/mongod.conf.orig -p $IP:27017:27017 mongo:3.6 变量名 作用说明 $CONTAINER_NAME 自定义的容器名字 $DATA_PATH 容器在宿主机上的数据卷路径 $OLD_DATA_PATH 待升级的老版本MongoDB备份数据 $CONFIG_PATH 新版MongoDB的配置文件目录 $IP MongoDB容器对外提供服务的IP地址 配置文件 123456789101112131415161718192021# Where and how to store data.storage: dbPath: /var/lib/mongodb journal: enabled: true engine: wiredTiger# where to write logging data. systemLog: destination: file logAppend: true path: /var/log/mongodb/mongod.log# network interfaces net: port: 27017 bindIp: 127.0.0.1# how the process runs processManagement: timeZoneInfo: /usr/share/zoneinfo 2、把 MongoDB 2.6的备份数据解压到$OLD_DATA_PATH 3、进入MongoDB 3.6的容器中执行以下命令 12docker exec -it $CONTAINER_NAME /bin/bash #进入docker并分配bash终端mongorestore data2/ #从data2目录中导入备份数据 OK，接下来静候佳音即可。中间会有一段漫长的导入数据，转换引擎，重建索引的过程。 当然，你要是土豪，用固态硬盘也是极好的。 4、最后一步，查看一下数据引擎。运行db.serverStatus()命令,查询结果包含如下内容即可： 12345\"storageEngine\" : &#123; \"name\" : \"wiredTiger\", \"supportsCommittedReads\" : true, \"readOnly\" : false, \"persistent\" : true","categories":[],"tags":[{"name":"MongoDB,Docker","slug":"MongoDB-Docker","permalink":"https://zhusas.github.io/tags/MongoDB-Docker/"}]}]}